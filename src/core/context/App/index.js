// @ts-check

/**
 * This file is part of the BlockLotto core functionality.
 * 
 * DO NOT EDIT THIS FILE DIRECTLY.
 * Any changes to this file may cause unexpected behavior.
 * Please consult the project maintainers before making modifications.
 */
import React, { createContext, useContext, useEffect, useState } from 'react';
import { useCashTab } from '../CashTab';
import { Modal } from 'antd';
import { bcrypto, KeyRing, TX, Coin, Script } from '@hansekontor/checkout-components';
const { SHA256 } = bcrypto;
import { useHistory } from 'react-router-dom';
import useBCH from '../../hooks/useBCH';
import { U64 } from 'n64';

// core modules
import { schrodingerOutscript, readTicketAuthCode, calculatePayout } from '../../utils/ticket';
import { useNotifications } from '../Notifications';
import TXUtil from '../../utils/txutil';
import playerWinningsTier from '../../constants/winningTiers';

export const AppContext = createContext/** @type {import('./types').AppContextValue} */({});

export const AppWrapper = ({ Loading, children, user }) => {
    const history = useHistory();
    const { wallet, unredeemedTickets, balance, addMinedTicketToStorage, addRedeemTxToStorage } = useCashTab();
    const { checkRedeemability, broadcastTx } = useBCH();
    const notify = useNotifications();

    /**
     * @typedef {number[]} PlayerNumbers
     * An array of 0 to 4 numbers, where each number is between 0 and 127.
     */
    /** @type {[PlayerNumbers, React.Dispatch<React.SetStateAction<PlayerNumbers>>]} */
    const [playerNumbers, setPlayerNumbers] = useState(
        /** @type {PlayerNumbers} */([])
    );

    /** @type {[string, (value: string) => void]} */
    const [loadingStatus, setLoadingStatus] = useState("");

    /** @type {[boolean, (value: boolean) => void]} */
    const [loader, setLoader] = useState(true);

    /** @type {Array} */
    const [ticketsToRedeem, setTicketsToRedeem] = useState([]);

    /** @type {Array} */
    const [gameTickets, setGameTickets] = useState([]);

    /** @type {[number, (value: number) => void]} */
    const [ticketQuantity, setTicketQuantity] = useState(1);

    const [protection, setProtection] = useState(true);

    const [affiliate, setAffiliate] = useState({});
    const [externalAid, setExternalAid] = useState(""); 

    useEffect(() => {
        const unlisten = history.listen(() => {
            setLoadingStatus("");
        });
        return () => unlisten();
    }, [history]);

    // get own affiliate data
    useEffect(() => {
        const getAffiliate = () => {
            // get aid
            const aidBuf = Buffer.from(wallet.Path1899.publicKey, 'hex');
            const aid = aidBuf.toString('base64');
            
            const query = new URLSearchParams({
                aid
            });
            const url = `${window.location.protocol}//${window.location.host}/#/?${query}`;

            console.log("setting affiliate", aid);
            setAffiliate({
                aid,
                url
            });
        }

        getAffiliate();
    }, [wallet]);

    // get external aid from url
    useEffect(() => {
        const getAidFromQuery = () => {
            const aidBase64FromQuery = new URLSearchParams(location.search).get('aid');

            if (aidBase64FromQuery) {
                try {
                    const aidBuf = Buffer.from(aidBase64FromQuery, 'base64');
                    const aidKeyring = new KeyRing(aidBuf);
                    const aidPubkey = aidKeyring.getPublicKey('hex');
                    console.log("aidPubkey", aidPubkey);
                    setExternalAid(aidPubkey);
                } catch(err) {
                    console.error('Invalid Affiliate ID:', err);
                }
            }
        }

        getAidFromQuery();

    }, []);

    const getMinedTicket = async (hash) => {
        const ticketRes = await fetch(`https://lsbx.nmrai.com/v1/ticket/${hash}`, {
            method: "GET",
            headers: new Headers({
                'Accept': "application/json",
                'Content-Type': "application/json"
            }),
            mode: "cors",
            signal: AbortSignal.timeout(20000),
        });
        if (ticketRes.status !== 200)
            notify({ type: "error", message: "API Error"});
        const minedTicket = await ticketRes.json();
        return minedTicket;
    }

    const redeemTicket = async (ticket) => {
        let minedTicket = ticket.parsed?.minedTicket;

        if (!minedTicket?.lottoSignature) {
            const issueHash = ticket.issueTx.hash;
            minedTicket = await getMinedTicket(issueHash);

            if (!minedTicket.lottoSignature) {
                notify({type: "error", message: "Ticket not redeemable"});
                return false;
            }

            await addMinedTicketToStorage(issueHash, minedTicket);
        } 

        const ttx = TX.fromRaw(minedTicket.hex, 'hex');

        // Stamp comes from Authorizer address 
        const authPubkey = ttx.inputs[0].script.getData(1);

        // Shrodinger
        const outScript = schrodingerOutscript(authPubkey);

        // Build payout tx
        const ptx = new TXUtil();

        // Add ticket input
        const pcoin = Coin.fromTX(ttx, 1, -1);
        ptx.addCoin(pcoin);

        // Add outputs from ttx OP_RETURN
        const ttxOpreturnAuthBuf = ttx.outputs[0].script.code[1].data;
        const parsedticketAuthCode = readTicketAuthCode(ttxOpreturnAuthBuf);

        // We also need the block header and block auth sig
        console.log("redeemTicket() minedTicket.lottoSignature", minedTicket.lottoSignature);
        const blockAuthSig = Buffer.from(minedTicket.lottoSignature, 'hex');

        const maxPayout = parsedticketAuthCode.txOutputs[0].script.toRaw().slice(-8)
        const { actualPayoutBE, tier, opponentNumbers, resultingNumbers } = calculatePayout(
            ttx.hash(),
            Buffer.from(minedTicket.block, 'hex').reverse(),
            parsedticketAuthCode.minterNumbers,
            maxPayout,
            playerWinningsTier.map(obj => obj.threshold)
        );

        console.log("actualPayout", actualPayoutBE);
        console.log('actualPayoutNum', U64.fromBE(actualPayoutBE).toNumber())

        // Set the actual payout
        parsedticketAuthCode.txOutputs[0].script = Script.fromRaw(Buffer.concat([
            parsedticketAuthCode.txOutputs[0].script.toRaw().slice(0, -8),
            actualPayoutBE
        ]))

        ptx.outputs = parsedticketAuthCode.txOutputs

        // Do signature
        const sigHashType = Script.hashType.ALL | Script.hashType.SIGHASH_FORKID;
        const flags = Script.flags.STANDARD_VERIFY_FLAGS;
        const playerKeyring = KeyRing.fromSecret(wallet.Path1899.fundingWif);
        ptx.template(playerKeyring); // prepares the template
        const sig = ptx.signature(0, outScript, pcoin.value, playerKeyring.privateKey, sigHashType, flags);
        const preimage = ptx.getPreimage(0, outScript, pcoin.value, sigHashType, false);
        // console.log('preimage length: ', Buffer.from(preimage.toString('hex'), 'hex').length)

        const items = [
            sig,
            playerKeyring.getPublicKey(),
            blockAuthSig, // block auth signature
            Buffer.from(preimage.toString('hex'), 'hex'),
            Buffer.from(minedTicket.header, 'hex'),
            ttx.toRaw(),
            outScript.toRaw()
        ];
        ptx.inputs[0].script.fromItems(items);
        // console.log("sigScript length", ptx.inputs[0].script.toRaw().length)

        console.log(ptx)
        const ptxHex = ptx.toRaw().toString('hex')
        // console.log(ptxHex)

        console.log('verify', ptx.verify())
        try {
            const ptxBroadcast = await broadcastTx(ptxHex)
            console.log('ptxBroadcast', ptxBroadcast)

            if (ptxBroadcast.success) {
                console.log('ptx id', ptx.txid())

                const redeemData = {
                    actualPayoutNum: U64.fromBE(actualPayoutBE).toNumber(),
                    tier,
                    opponentNumbers,
                    resultingNumbers
                }
                await addRedeemTxToStorage(ptx, redeemData);

                const redeemHash = ptx.txid();

                const outstandingTickets = ticketsToRedeem;
                outstandingTickets.shift();
                setTicketsToRedeem(outstandingTickets);

                return redeemHash;
            } else {
                notify({type: "error", message: "Broadcasting Unsuccesful"});
                return;
            }
        } catch (err) {
            console.error(err);
            notify({type: "error", message: "Broadcasting Error"});
            return;
        }
    }

    return (
        <AppContext.Provider value={{
            protection,
            user,
            wallet,
            unredeemedTickets,
            balance,
            playerNumbers,
            ticketsToRedeem,
            gameTickets,
            ticketQuantity,
            affiliate,
            externalAid,
            checkRedeemability, 
            redeemTicket,
            setTicketQuantity,
            setProtection,
            setLoadingStatus,
            setPlayerNumbers,
            setTicketsToRedeem,
            setGameTickets
        }}>
            {children}
            {loadingStatus && <Loading>{loadingStatus}</Loading>}
        </AppContext.Provider>
    )
};

export const AppProvider = ({ Loading, children }) => {

    const { wallet } = useCashTab();
    const [modal, modalHolder] = Modal.useModal();

    const [user, setUser] = useState({});

    /** @type {[boolean, (value: boolean) => void]} */
    const [geoProtection, setGeoProtection] = useState(true);

    /** @type {[boolean, (value: boolean) => void]} */
    const [kycProtection, setKycProtection] = useState(true);

    /** @type {[boolean, (value: boolean) => void]} */
    const [isLoading, setIsLoading] = useState(true);

    /** @type {[boolean, (value: boolean) => void]} */
    const [checksDone, setChecksDone] = useState(false);

    // get user data
    useEffect(() => {
        const getUser = async () => {
            try {
                const accessRes = await fetch(`https://lsbx.nmrai.com/v1/access/${wallet.Path1899.publicKey}`, {
                    signal: AbortSignal.timeout(20000),
                    headers: new Headers({
                        "Content-Type": "application/json"
                    })
                });
                const accessData = await accessRes.json();

                const msg = Buffer.from(accessData.access, 'utf-8');
                const keyring = KeyRing.fromSecret(wallet.Path1899.fundingWif, null);
                const sig = keyring.sign(SHA256.digest(msg));

                const userRes = await fetch("https://lsbx.nmrai.com/v1/user/", {
                    method: "POST",
                    signal: AbortSignal.timeout(20000),
                    headers: new Headers({
                        "Content-Type": "application/json"
                    }),
                    body: JSON.stringify({
                        access: accessData.access,
                        pubkey: wallet.Path1899.publicKey,
                        signature: sig.toString('hex')
                    }),
                });
                const user = await userRes.json();

                // evaluate access based on kyc
                let accessDenied = false;
                if (user.kyc_status?.includes("declined") || user.kyc_status?.includes("error")) {
                    console.log("kyc declined")
                    accessDenied = true;
                    // nothing is allowed
                    // show  info modal
                    const modalConfig = {
                        title: "Access denied",
                        content: "Your KYC has been declined.",
                    };
                    modal.info(modalConfig);
                } else if (user.kyc_status === "needs_review") {
                    console.log("kyc needs review");
                    accessDenied = false;
                    // user has to wait until email notification
                    // show info modal
                    const modalConfig = {
                        title: "Your KYC Needs Review",
                        content: "You will receive an email when this issue is resolved.",
                    };
                    modal.info(modalConfig);
                } else {
                    console.log("kyc approved or outstanding")
                    // user is either approved or not yet kyced
                    setKycProtection(false);
                }

                // evaluate access based on ip
                if (!accessDenied) {
                    // get ip data if missing
                    if (!user.ipGeo) {
                        const geoRes = await fetch(`https://lsbx.nmrai.com/v1`, {
                            signal: AbortSignal.timeout(20000)
                        });
                        const geoData = await geoRes.json();
                        console.log("geodata", geoData);

                        user.ipGeo = geoData.ipGeo;
                    }

                    // evaluate ip access
                    if (user.ipGeo.ticketPurchase) {
                        console.log("allow ticket purchase")
                        // everything is allowed
                        setGeoProtection(false);
                    } else if (user.ipGeo.affiliate) {
                        console.log("allow affiliate")
                        // show info screen for affiliates
                        const modalConfig = {
                            title: "Access restricted",
                            content: "You can not purchase tickets, but you can be an affiliate",
                            onOk: () => {
                                setGeoProtection(false);
                            },
                        };
                        modal.info(modalConfig);
                    } else {
                        console.log("allow nothing")
                        accessDenied = true;
                        // nothing is allowed
                        // show  info modal
                        const modalConfig = {
                            title: "Access denied",
                            content: "You can not access this site from your location.",
                        };
                        modal.info(modalConfig);
                    }
                }

                // pass user data 
                setUser(user);
                setChecksDone(true);
            } catch (error) {
                console.error("Error fetching user data:", error);
            } finally {
                setIsLoading(false);
            }
        }

        getUser();
    }, [wallet]);

    if (isLoading) {
        return <>{modalHolder}<Loading>Loading Wallet...</Loading></>;
    }

    if (geoProtection || kycProtection || !checksDone) {
        return <>{modalHolder}<Loading>Access Denied!</Loading></>;
    }

    if (!user || Object.keys(user).length === 0) {
        return <>{modalHolder}<Loading>User Not Found!</Loading></>;
    }

    return (
        <AppWrapper user={user} Loading={Loading}>
            {children}
        </AppWrapper>
    )
}

/**
 * Custom hook to access AppContext.
 * 
 * @returns {import('./types').AppContextValue} The context object, containing wallet and associated functions.
 */
export const useApp = () => {
    const context = useContext(AppContext);
    if (!context) {
        throw new Error("useApp must be used within a AppProvider");
    }
    // @ts-ignore
    return context;
};