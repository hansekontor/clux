// @ts-check

/**
 * This file is part of the BlockLotto core functionality.
 * 
 * DO NOT EDIT THIS FILE DIRECTLY.
 * Any changes to this file may cause unexpected behavior.
 * Please consult the project maintainers before making modifications.
 */
import React, { createContext, useContext, useEffect, useState } from 'react';
import { useCashTab } from '../CashTab';
import { Modal } from 'antd';
import { bcrypto, KeyRing } from '@hansekontor/checkout-components';
const { SHA256 } = bcrypto;
import { useHistory } from 'react-router-dom';


export const AppContext = createContext/** @type {import('./types').AppContextValue} */({});

export const AppWrapper = ({ Loading, children, user }) => {
    const history = useHistory();
    const { wallet, unredeemedTickets, balance } = useCashTab();

    /**
     * @typedef {number[]} PlayerNumbers
     * An array of 0 to 4 numbers, where each number is between 0 and 127.
     */
    /** @type {[PlayerNumbers, React.Dispatch<React.SetStateAction<PlayerNumbers>>]} */
    const [playerNumbers, setPlayerNumbers] = useState(
        /** @type {PlayerNumbers} */([])
    );

    /** @type {[string, (value: string) => void]} */
    const [loadingStatus, setLoadingStatus] = useState("");

    /** @type {[boolean, (value: boolean) => void]} */
    const [loader, setLoader] = useState(true);

    /** @type {[object, (value: object) => void]} */
    const [activeTicket, setActiveTicket] = useState({});

    /** @type {[number, (value: number) => void]} */
    const [ticketQuantity, setTicketQuantity] = useState(1);

    const [payout, setPayout] = useState(false);
    const [protection, setProtection] = useState(true);

    const [affiliate, setAffiliate] = useState({});
    const [externalAid, setExternalAid] = useState("");

    useEffect(() => {
        const unlisten = history.listen(() => {
            setLoadingStatus("");
        });
        return () => unlisten();
    }, [history]);

    // get own affiliate data
    useEffect(() => {
        const getAffiliate = () => {
            // get aid
            const aidBuf = Buffer.from(wallet.Path1899.publicKey, 'hex');
            const aid = aidBuf.toString('base64');
            
            const query = new URLSearchParams({
                aid
            });
            const url = `${window.location.protocol}//${window.location.host}/#/?${query}`;

            console.log("setting affiliate", aid);
            setAffiliate({
                aid,
                url
            });
        }

        getAffiliate();
    }, [wallet]);

    // get external aid from url
    useEffect(() => {
        const getAidFromQuery = () => {
            const aidBase64FromQuery = new URLSearchParams(location.search).get('aid');

            if (aidBase64FromQuery) {
                try {
                    const aidBuf = Buffer.from(aidBase64FromQuery, 'base64');
                    const aidKeyring = new KeyRing(aidBuf);
                    const aidPubkey = aidKeyring.getPublicKey('hex');
                    console.log("aidPubkey", aidPubkey);
                    setExternalAid(aidPubkey);
                } catch(err) {
                    console.error('Invalid Affiliate ID:', err);
                }
            }
        }

        getAidFromQuery();

    }, []);

    return (
        <AppContext.Provider value={{
            protection,
            user,
            wallet,
            unredeemedTickets,
            balance,
            playerNumbers,
            activeTicket,
            redeemAll,
            payout,
            ticketQuantity,
            affiliate,
            externalAid,
            setTicketQuantity,
            setProtection,
            setLoadingStatus,
            setPlayerNumbers,
            setActiveTicket,
            setRedeemAll,
        }}>
            {children}
            {loadingStatus && <Loading>{loadingStatus}</Loading>}
        </AppContext.Provider>
    )
};

export const AppProvider = ({ Loading, children }) => {

    const { wallet } = useCashTab();
    const [modal, modalHolder] = Modal.useModal();

    const [user, setUser] = useState({});

    /** @type {[boolean, (value: boolean) => void]} */
    const [geoProtection, setGeoProtection] = useState(true);

    /** @type {[boolean, (value: boolean) => void]} */
    const [kycProtection, setKycProtection] = useState(true);

    /** @type {[boolean, (value: boolean) => void]} */
    const [isLoading, setIsLoading] = useState(true);

    /** @type {[boolean, (value: boolean) => void]} */
    const [checksDone, setChecksDone] = useState(false);

    useEffect(() => {
        const getUser = async () => {
            try {
                const accessRes = await fetch(`https://lsbx.nmrai.com/v1/access/${wallet.Path1899.publicKey}`, {
                    signal: AbortSignal.timeout(20000),
                    headers: new Headers({
                        "Content-Type": "application/json"
                    })
                });
                const accessData = await accessRes.json();

                const msg = Buffer.from(accessData.access, 'utf-8');
                const keyring = KeyRing.fromSecret(wallet.Path1899.fundingWif, null);
                const sig = keyring.sign(SHA256.digest(msg));

                const userRes = await fetch("https://lsbx.nmrai.com/v1/user/", {
                    method: "POST",
                    signal: AbortSignal.timeout(20000),
                    headers: new Headers({
                        "Content-Type": "application/json"
                    }),
                    body: JSON.stringify({
                        access: accessData.access,
                        pubkey: wallet.Path1899.publicKey,
                        signature: sig.toString('hex')
                    }),
                });
                const user = await userRes.json();

                // evaluate access based on kyc
                let accessDenied = false;
                if (user.kyc_status?.includes("declined") || user.kyc_status?.includes("error")) {
                    console.log("kyc declined")
                    accessDenied = true;
                    // nothing is allowed
                    // show  info modal
                    const modalConfig = {
                        title: "Access denied",
                        content: "Your KYC has been declined.",
                    };
                    modal.info(modalConfig);
                } else if (user.kyc_status === "needs_review") {
                    console.log("kyc needs review");
                    accessDenied = false;
                    // user has to wait until email notification
                    // show info modal
                    const modalConfig = {
                        title: "Your KYC Needs Review",
                        content: "You will receive an email when this issue is resolved.",
                    };
                    modal.info(modalConfig);
                } else {
                    console.log("kyc approved or outstanding")
                    // user is either approved or not yet kyced
                    setKycProtection(false);
                }

                // evaluate access based on ip
                if (!accessDenied) {
                    // get ip data if missing
                    if (!user.ipGeo) {
                        const geoRes = await fetch(`https://lsbx.nmrai.com/v1`, {
                            signal: AbortSignal.timeout(20000)
                        });
                        const geoData = await geoRes.json();
                        console.log("geodata", geoData);

                        user.ipGeo = geoData.ipGeo;
                    }

                    // evaluate ip access
                    if (user.ipGeo.ticketPurchase) {
                        console.log("allow ticket purchase")
                        // everything is allowed
                        setGeoProtection(false);
                    } else if (user.ipGeo.affiliate) {
                        console.log("allow affiliate")
                        // show info screen for affiliates
                        const modalConfig = {
                            title: "Access restricted",
                            content: "You can not purchase tickets, but you can be an affiliate",
                            onOk: () => {
                                setGeoProtection(false);
                            },
                        };
                        modal.info(modalConfig);
                    } else {
                        console.log("allow nothing")
                        accessDenied = true;
                        // nothing is allowed
                        // show  info modal
                        const modalConfig = {
                            title: "Access denied",
                            content: "You can not access this site from your location.",
                        };
                        modal.info(modalConfig);
                    }
                }

                // pass user data 
                setUser(user);
                setChecksDone(true);
            } catch (error) {
                console.error("Error fetching user data:", error);
            } finally {
                setIsLoading(false);
            }
        }

        getUser();
    }, [wallet]);

    if (isLoading) {
        return <>{modalHolder}<Loading>Loading Wallet...</Loading></>;
    }

    if (geoProtection || kycProtection || !checksDone) {
        return <>{modalHolder}<Loading>Access Denied!</Loading></>;
    }

    if (!user || Object.keys(user).length === 0) {
        return <>{modalHolder}<Loading>User Not Found!</Loading></>;
    }

    return (
        <AppWrapper user={user} Loading={Loading}>
            {children}
        </AppWrapper>
    )
}

/**
 * Custom hook to access AppContext.
 * 
 * @returns {import('./types').AppContextValue} The context object, containing wallet and associated functions.
 */
export const useApp = () => {
    const context = useContext(AppContext);
    if (!context) {
        throw new Error("useApp must be used within a AppProvider");
    }
    // @ts-ignore
    return context;
};