// @ts-check

/**
 * This file is part of the BlockLotto core functionality.
 * 
 * DO NOT EDIT THIS FILE DIRECTLY.
 * Any changes to this file may cause unexpected behavior.
 * Please consult the project maintainers before making modifications.
*/

import React, { createContext, useContext, useEffect, useMemo, useState } from 'react';
import { getWalletState, isValidStoredWallet } from '../../utils/cashMethods';
import getWalletOnStartup from './services/getWalletOnStartup';
import createNewWallet from './services/createNewWallet';
import BigNumber from 'bignumber.js';
import useAsyncTimeout from '../../hooks/useAsyncTimeout';
import getWallet from './services/getWallet';
import isEqual from 'lodash.isequal';
import useBCH from '../../hooks/useBCH';
import updateWalletFn from './services/updateWallet';
import getActiveWallet from './services/getActiveWallet';
import addIssueTxsFn from './services/addIssueTx';
import getWalletDetails from './services/getWalletDetails';
import getSavedWallets from './services/getSavedWallet';
import renameWallet from './services/renameWallet';
import deleteWallet from './services/deleteWallet';
import addNewSavedWallet from './services/addNewSavedWallet';
import validateMnemonic from './utils/validateMnemonic';
import changeCashtabSettingsFn from './services/changeCashTabSetting';
import addMinedTicketToStorageFn from './services/addMinedTicketToStorage';
import addRedeemTxToStorageFn from './services/addRedeemTxToStorage';
import addCashoutFn from './services/addCashout';
import migrateLegacyWallet from './services/migrateLegacyWallet';
import forceWalletUpdateFn from './services/forceWalletUpdate';
import createWalletFn from './services/createWallet';
import activateWalletFn from './services/activateWallet';

export const CashTabContext = createContext/** @type {CashTabContextType} */({});

export const CashTabWrapper = ({ children, passWallet }) => {
    const { getTicketData } = useBCH();

    /** @type {[Wallet, (value: Wallet) => void]} */
    const [wallet, setWallet] = useState(passWallet);

    /** @type {[boolean, (value: boolean) => void]} */
    const [apiError, setApiError] = useState(false);

    /** @type {[boolean, (value: boolean) => void]} */
    const [cashtabSettings, setCashtabSettings] = useState(false);

    /** @type {[boolean, (value: boolean) => void]} */
    const [loading, setLoading] = useState(false);

    const { tickets, slpBalancesAndUtxos } = getWalletState(wallet);

    /**
     * Updates the wallet state based on the current data.
     * 
     * This function processes the wallet's state, fetches relevant ticket data, 
     * updates ticket history, and adjusts the wallet's balances and UTXOs. 
     * It also handles any errors during the update process.
     * 
     * @param {Object} wallet - The current wallet object that needs to be updated.
     * 
     * @returns {Promise<void>} Resolves once the wallet state is updated successfully.
     */
    const updateWallets = async ({ wallet }) => {
        return await updateWalletFn({ wallet, getTicketData, setWallet, setApiError });
    }

    /**
     * Adds issue transactions to ticket history and updates the wallet state.
     * 
     * This function processes the provided transactions, updates the ticket history, and manages the wallet's state.
     * It also updates the wallet's SLP balances and UTXOs and handles errors during the process.
     *
     * @param {Array<Object>} txs - The new issuance transactions to be added to ticket history.
     * @param {Array<Object>} coinsUsed - List of UTXOs that were used in the payment transaction.
     * @param {Array<Object>} [paymentTxs] - Optional array of payment transactions to process SLP change.
     * 
     * @returns {Promise<void>} Resolves once the transactions are processed and the wallet state is updated.
     */
    const addIssueTxs = async (txs, coinsUsed, paymentTxs) => {
        return await addIssueTxsFn({ wallet, setWallet, setApiError }, txs, coinsUsed, paymentTxs);
    }

    /**
     * Updates the Cashtab settings and stores them in `localforage`.
     * 
     * This function updates the settings for a specific key in the Cashtab settings object.
     * It performs the following steps:
     * 1. Sets the loading state to true to prevent UI updates during the operation.
     * 2. Retrieves the current settings from `localforage`.
     * 3. Validates the key and new value for the settings change.
     * 4. Updates the settings in both the state and `localforage`.
     * 5. Sets the loading state back to false after the operation.
     * 
     * @param {string} key - The key of the setting to be updated.
     * @param {string|number} newValue - The new value to set for the specified setting key.
     * 
     * @returns {Promise<void>} 
    */
    const changeCashtabSettings = async (key, newValue) => {
        return await changeCashtabSettingsFn({ setLoading, setCashtabSettings }, key, newValue);
    }

    /**
     * Adds a mined ticket to the wallet's state and updates the stored wallet information.
     * 
     * This function updates the wallet's ticket state by adding the mined ticket details 
     * to an existing ticket, identified by its issue hash. It also updates the wallet state 
     * in local storage and triggers a wallet update in the application state.
     * 
     * @param {string} issueHash - The unique hash identifying the ticket issue transaction.
     * @param {Object} minedTicket - The mined ticket object containing details such as hex data.
     * 
     * @returns {Promise<void>} - A promise indicating the success or failure of the operation.
     */
    const addMinedTicketToStorage = async (issueHash, minedTicket) => {
        return await addMinedTicketToStorageFn({ setWallet, wallet, setApiError }, issueHash, minedTicket);
    }

    /**
     * Adds a redeem transaction (tx) to the wallet's state, updating both the ticket history 
     * and the SLP balances and UTXOs.
     * 
     * This function takes a redeem transaction and its associated data, processes it by adding 
     * the SLP transaction data, and then updates the ticket history and wallet state with the 
     * new transaction information. It then writes the updated wallet state back to the storage.
     * 
     * @param {Object} tx - The redeem transaction object (without SLP data) to be added to the wallet's state.
     * @param {Object} redeemData - The data related to the redeem transaction, used to process the ticket redemption.
     * 
     * @returns {Promise<void>} - A promise that resolves when the transaction is successfully added to the wallet's state.
     */
    const addRedeemTxToStorage = async (tx, redeemData) => {
        return await addRedeemTxToStorageFn({ setWallet, wallet, setApiError }, tx, redeemData);
    }

    /**
     * Adds a cashout transaction to the wallet's state by processing the send transactions (txs) 
     * and updating the SLP balances and UTXOs. It also removes the coins that were used in the transaction 
     * and updates the wallet state accordingly.
     * 
     * This function performs the following steps:
     * 1. Removes the used coins (burned) from the wallet's SLP balances and UTXOs.
     * 2. Adds SLP data to each send transaction.
     * 3. Updates the wallet's state with the new SLP balances and UTXOs.
     * 4. Writes the updated wallet state to the storage.
     * 
     * @param {Array} txs - An array of transactions (txs) to be processed as part of the cashout.
     * @param {Array} coinsBurned - An array of coins that were used (burned) in the transaction, which need to be removed from the wallet's UTXOs.
     * 
     * @returns {Promise<void>} - A promise that resolves when the transaction is successfully processed and the state is updated.
     */
    const addCashout = async (txs, coinsBurned) => {
        return await addCashoutFn({ wallet, setWallet, setApiError }, txs, coinsBurned);
    }

    /**
    * Forces an update of the wallet by fetching the current wallet state 
    * and passing it to the provided update function.
    * 
    * This function retrieves the current wallet using `getWallet()`, 
    * and then calls the `updateWallet` function with the fetched wallet 
    * as part of the update process.
    * 
    * @returns {Promise<*>} - The result of calling `updateWallet` with the current wallet. 
    *                          It returns whatever `updateWallet` returns.
    */
    const forceWalletUpdate = async () => {
        return await forceWalletUpdateFn(updateWallets);
    }

    /**
     * Creates a new wallet and updates the wallet state.
     * 
     * This function creates a new wallet, either from an imported mnemonic or by generating a new one, 
     * then sets the wallet in the state. If the wallet is imported, it also updates the wallet with the 
     * existing tickets and balance information. 
     * 
     * @param {string} [importMnemonic] - An optional mnemonic string. If provided, the wallet is created using the imported mnemonic.
     *                                    If not provided, a new wallet is generated instead.
     * 
     * @returns {Promise<void>} - A promise that resolves when the wallet is successfully created and state is updated.
     */
    const createWallet = async (importMnemonic) => {
        return await createWalletFn({ setWallet, updateWallets, setLoading }, importMnemonic);
    }

    /**
     * Activates an existing wallet, either by loading it from storage or by fetching missing data from an API.
     * 
     * This function checks if the wallet has the necessary state parameters stored. If so, it activates the wallet 
     * immediately. If the wallet is missing state parameters (likely from a legacy or unmigrated wallet), 
     * it fetches the missing data via an API before activation.
     * 
     * @param {Object} walletToActivate - The wallet that needs to be activated.
     * 
     * @returns {Promise<void>} - A promise that resolves once the wallet is activated, either immediately or after fetching data.
     */
    const activateWallet = async (walletToActivate) => {
        return await activateWalletFn({ setLoading, updateWallets, setWallet }, walletToActivate);
    }

    /** @type {number} */
    const unredeemedTickets = /** @type {Array<{ redeemTx?: string }>} */ (tickets).filter(
        (ticket) => !ticket.redeemTx
    ).length;

    /** @type {number} */
    const balance = useMemo(() => {
        if (!slpBalancesAndUtxos?.tokens?.length) return 0;
        const token = slpBalancesAndUtxos.tokens[0];
        if (!("balance" in token)) return 0;

        const rawBalance = new BigNumber({ ...token.balance, _isBigNumber: true }).toNumber();
        const decimals = token.info.decimals;
        return rawBalance / Math.pow(10, decimals);
    }, [slpBalancesAndUtxos]);

    // Update wallet state every 5s
    useAsyncTimeout(async () => {
        if (wallet && isValidStoredWallet(wallet)) {
            const newWallet = await getWallet();

            if (!isEqual(wallet, newWallet)) {
                setWallet(newWallet);
            }
        }
    }, 5000);

    return (
        <CashTabContext.Provider value={{
            wallet,
            balance,
            unredeemedTickets,
            loading,
            apiError,
            cashtabSettings,
            changeCashtabSettings,
            getActiveWallet,
            forceWalletUpdate,
            validateMnemonic,
            getWalletDetails,
            getSavedWallets,
            migrateLegacyWallet,
            createWallet,
            activateWallet,
            addNewSavedWallet,
            renameWallet,
            deleteWallet,
            addIssueTxs,
            addMinedTicketToStorage,
            addRedeemTxToStorage,
            addCashout,
            setLoading
        }}>
            {children}
        </CashTabContext.Provider>
    )
};

export const CashTabProvider = ({ children, Loading }) => {

    const [wallet, setWallet] = useState(null);

    /** @type {[boolean, (value: boolean) => void]} */
    const [isLoading, setIsLoading] = useState(true);

    useEffect(() => {
        const fetchWallet = async () => {
            try {
                const walletFromStorage = await getWalletOnStartup();
                if (walletFromStorage) {
                    setWallet(walletFromStorage);
                } else {
                    const newWallet = await createNewWallet();
                    setWallet(newWallet);
                }
            } catch (error) {
                console.error("Error fetching wallet", error);
            } finally {
                setIsLoading(false);
            }
        };

        fetchWallet();
    }, []);

    if (isLoading) {
        return <Loading>Loading Wallet...</Loading>;
    }

    if (!wallet || !isValidStoredWallet(wallet)) {
        console.error("No wallet found");
        return <Loading>No Wallet Found!</Loading>; // Handle case where wallet is not found
    }

    return (
        <CashTabWrapper passWallet={wallet}>
            {children}
        </CashTabWrapper>
    )
}


/**
 * Custom hook to access CashTabContext.
 * 
 * @returns {CashTabContextType} The context object, containing wallet and associated functions.
 */
export const useCashTab = () => {
    const context = useContext(CashTabContext);
    if (!context) {
        throw new Error("useCashTab must be used within a CashTabProvider");
    }
    // @ts-ignore
    return context;
};