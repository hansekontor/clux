/**
 * This file is part of the BlockLotto core functionality.
 * 
 * DO NOT EDIT THIS FILE DIRECTLY.
 * Any changes to this file may cause unexpected behavior.
 * Please consult the project maintainers before making modifications.
*/

import React, { createContext, useContext, useEffect, useState } from 'react';
import { useHistory } from 'react-router-dom';
import bio from 'bufio';
import { U64 } from 'n64';
import { stringify as uuidStringify } from 'uuid';
import {
    Payment,
    PaymentRequest,
    PaymentACK
} from 'b70-checkout';
import {
    KeyRing,
    TX,
    MTX,
    bcrypto,
    Script,
    Coin
} from '@hansekontor/checkout-components';
const { SHA256 } = bcrypto;
import BigNumber from 'bignumber.js';

// core functions
import { useCashTab } from '@core/context/CashTab';
import { getWalletState } from '@core/utils/cashMethods';
import sleep from '@core/utils/sleep';
import { useNotifications } from '@core/context/Notifications';
import { useApp } from '@core/context/App';
import checkoutAllowedCountryOptions from '@core/constants/checkoutAllowedCountryOptions';

const ticketPrice = 10;

const signMessage = (secret, msg) => {
    const keyring = KeyRing.fromSecret(secret);
    const sig = keyring.sign(msg);

    return sig;
}

export const CheckoutContext = createContext();

export function CheckoutProvider({ children }) {
    const history = useHistory();
    const notify = useNotifications();

    const { setLoadingStatus, playerNumbers, user } = useApp();

    // find ticket indicator
    const { wallet, forceWalletUpdate, addIssueTxs } = useCashTab();
    const { tickets, slpBalancesAndUtxos } = getWalletState(wallet);
    const token = slpBalancesAndUtxos.tokens ? slpBalancesAndUtxos.tokens[0] : false;
    let maxEtokenTicketQuantity = 0;
    if (token) {
        const balance = (new BigNumber({ ...token.balance, _isBigNumber: true }).toNumber()) / 100;
        maxEtokenTicketQuantity = Math.floor(balance / ticketPrice);
    }

    // states
    const [isFirstRendering, setFirstRendering] = useState(true);
    const [hasAgreed, setHasAgreed] = useState(false);
    const [ticketIssued, setTicketIssued] = useState(false);
    const [paymentProcessor, setPaymentProcessor] = useState("NMIC");
    const [isKYCed, setIsKYCed] = useState(false);
    const [kycConfig, setKycConfig] = useState(false);
    const [paymentRequest, setPaymentRequest] = useState(false);
    const [paymentMetadata, setPaymentMetadata] = useState(false);
    const [ticketQuantity, setTicketQuantity] = useState(1);
    const [showPaymentForm, setShowPaymentForm] = useState(false);
    const [ticketQtyError, setTicketQtyError] = useState(false);
    const [kycAccessToken, setKycAccessToken] = useState(false);
    const [emailError, setEmailError] = useState(false);
    const [countryError, setCountryError] = useState(false);
    const [hasEmail, setHasEmail] = useState(false);
    const [showKyc, setShowKyc] = useState(false);
    const [authPayment, setAuthPayment] = useState(false);
    const [kycCancelCount, setKycCancelCount] = useState(0);

    // useEffect(() => {
    //     let isMounted = true;

    //     const checkPlayerNumbers = async () => {
    //         if (!playerNumbers && isMounted) {
    //             setLoadingStatus("PLAYER NUMBERS ARE MISSING");
    //             history.push("/select");
    //         }
    //     };

    //     checkPlayerNumbers();

    //     return () => { isMounted = false };  // Cleanup function
    // }, [playerNumbers]);

    useEffect(async () => {
        console.log("CHECKOUT user", user);
        if (user && !user.ipGeo.ticketPurchase) {
            setLoadingStatus("ACCESS DENIED");
            await sleep(2000);
            history.push("/select");
        }
    }, [user])

    // skip email/kyc prompt if email already available
    useEffect(async () => {
        if (user.email)
            setHasEmail(true);

        if (user.kyc_status?.includes("approved") || tickets.length > 0) {
            setIsKYCed(true);
        } else if (user.kyc_status === "needs_review") {
            setLoadingStatus("KYC NEEDS REVIEW")
            return repeatOnboarding();
        } else if (user.kyc_status?.includes("declined")) {
            // user usually should not get here in this case
            setLoadingStatus("ACCESS DENIED")
            return repeatOnboarding();
        }

    }, [user])

    // finalize payment with paymentMetadata (payment token)
    useEffect(async () => {
        try {
            if (paymentMetadata && paymentRequest && !ticketIssued) {
                setLoadingStatus("PROCESSING");
                const type = paymentProcessor === "etoken" ? paymentProcessor : "fiat";
                const authonly = type === "fiat" && !isKYCed;
                console.log("authonly", authonly);
                const { payment, kycToken, coinsUsed } = await buildPayment(
                    type,
                    authonly
                );
                console.log("init payment", payment.toRaw().toString("hex"))
                setKycAccessToken(kycToken);
                // setLoadingStatus(false);
                const rawPaymentRes = await fetch("https://lsbx.nmrai.com/v1/pay", {
                    method: "POST",
                    headers: new Headers({
                        'Content-Type': `application/${type}-payment`
                    }),
                    signal: AbortSignal.timeout(20000),
                    body: payment.toRaw()
                });

                if (rawPaymentRes.status !== 200) {
                    const message = await rawPaymentRes.text();
                    throw new Error(message);
                }

                if (type === "fiat" && authonly) {
                    const response = await rawPaymentRes.json();
                    console.log("auth res", response);
                    setAuthPayment({
                        rawPayment: payment.toRaw(),
                        coinsUsed
                    });
                    setShowKyc(true);
                    setLoadingStatus(false);
                } else {
                    const paymentResArrayBuf = await rawPaymentRes.arrayBuffer();
                    const response = Buffer.from(paymentResArrayBuf);

                    const ack = PaymentACK.fromRaw(response);
                    console.log(ack.memo);
                    const rawTransactions = ack.payment.transactions;
                    const ticketTxs = rawTransactions.map(r => TX.fromRaw(r));
                    console.log(ticketTxs.map(tx => tx.toJSON()));

                    setTicketIssued(true);

                    // put txs in storage
                    const paymentTxs = payment.transactions.map(raw => TX.fromRaw(raw));
                    await addIssueTxs(ticketTxs, coinsUsed, paymentTxs);

                    // wait until ticket has been added to storage
                    await sleep(5000);

                    // pass hash for waiting room to find parsed ticket in storage
                    history.push({
                        pathname: "/waitingroom",
                        state: {
                            issueHash: ticketTxs[0].rhash()
                        }
                    });
                }
            }
        } catch (err) {
            console.error(err);
            setLoadingStatus("AN ERROR OCCURED");
            await sleep(3000);
            history.push("/select");
        }
    }, [paymentMetadata, paymentRequest])

    useEffect(() => {
        if (kycConfig) {
            window.HyperKYCModule.launch(kycConfig, handleKYCResult);
        }
    }, [kycConfig])

    useEffect(async () => {
        if (hasAgreed) {
            await forceWalletUpdate();
        }
    }, [hasAgreed])

    // initialize payment request
    const getPaymentRequest = async () => {
        console.log("get invoice for qnt", ticketQuantity);
        const res = await fetch("https://lsbx.nmrai.com/v1/invoice", {
            method: "POST",
            headers: new Headers({
                'Accept': "application/etoken-paymentrequest",
                'Content-Type': "application/json"
            }),
            mode: "cors",
            signal: AbortSignal.timeout(20000),
            body: JSON.stringify({
                quantity: ticketQuantity
            }),
        });
        // console.log("res", res);
        const invoiceRes = await res.arrayBuffer();
        const invoiceBuf = Buffer.from(invoiceRes);

        const pr = PaymentRequest.fromRaw(invoiceBuf);

        console.log("pr", pr);
        setPaymentRequest(pr);
    };

    const repeatOnboarding = () => {
        return history.push({
            pathname: "/",
            state: {
                repeatOnboarding: true
            }
        })
    };

    const buildPayment = async (
        type,
        authonly,
    ) => {
        // get message to sign
        const merchantData = paymentRequest.paymentDetails.getData('json');
        console.log("merchant data", merchantData);
        const paymentDataBuf = Buffer.from(merchantData.paymentdata, 'hex');
        const br = bio.read(paymentDataBuf);
        const id = uuidStringify(br.readBytes(16));
        const amount = br.readU32() / 100;
        console.log({ id, amount });

        const kycToken = merchantData.kyctoken;

        const bw = bio.write();
        bw.writeBytes(paymentDataBuf)
        const playerNumbersBuf = Buffer.from(playerNumbers, 'hex');
        bw.writeBytes(playerNumbersBuf);
        const payment = new Payment({
            memo: paymentRequest.paymentDetails.memo,
        });

        const coinsUsed = [];
        if (type === "fiat") {
            bw.writeBytes(Buffer.from(paymentProcessor, 'utf-8'));
            bw.writeVarString(paymentMetadata);
        } else {
            // get token coins
            const sortedTokenUtxos = slpBalancesAndUtxos.slpUtxos.filter(u => u.slp?.tokenId && ['MINT', 'SEND'].includes(u.slp.type))
                .sort((a, b) => parseInt(a.slp.value) - parseInt(b.slp.value));
            console.log("sortedTokenUtxos", sortedTokenUtxos);

            // construct tx
            const tx = new MTX();
            const prOutputs = paymentRequest.paymentDetails.outputs;
            for (let i = 0; i < prOutputs.length; i++) {
                tx.addOutput(Script.fromRaw(prOutputs[i].script), prOutputs[i].value);
            }
            console.log("tx.outputs", tx.outputs);

            let baseAmount = amount * 100;
            console.log("baseAmount", baseAmount);
            for (let i = 0; i < sortedTokenUtxos.length; i++) {
                const utxo = sortedTokenUtxos[i];
                tx.addCoin(Coin.fromJSON(utxo));
                coinsUsed.push(utxo);
                baseAmount -= parseInt(utxo.slp.value);
                if (baseAmount <= 0)
                    break;
            }

            // error will lead to general loading screen
            if (baseAmount > 0)
                throw new Error('Insufficient token funds in address');

            const baseChange = parseInt(baseAmount * -1);
            console.log("baseChange", baseChange);
            if (baseChange > 0) {
                tx.outputs[0].script.pushData(U64.fromInt(baseChange).toBE(Buffer)).compile();
                tx.addOutput(wallet.Path1899.cashAddress, 546);
                console.log("added change to outputs", tx.outputs);
            }

            // sign tx
            const hashTypes = Script.hashType;
            const sighashType = hashTypes.ALL | hashTypes.ANYONECANPAY | hashTypes.SIGHASH_FORKID;

            const buyerKeyring = KeyRing.fromSecret(wallet.Path1899.fundingWif);
            const hex = tx.toRaw().toString('hex')
            console.log("hex", hex);

            tx.sign(buyerKeyring, sighashType);
            const additionalSatsNeeded = tx.getMinFee() - tx.getFee();
            console.log("addtionalSatsNeeded", additionalSatsNeeded);
            console.log(tx);
            payment.transactions.push(tx.toRaw());
            payment.refundTo.push({
                value: 546,
                script: Script.fromAddress(wallet.Path1899.cashAddress).toRaw()
            });
        }

        const msgBuf = bw.render();
        console.log("msgBuf", msgBuf);

        // get signature
        const sigBuf = signMessage(wallet.Path1899.fundingWif, msgBuf);

        payment.setData({
            authonly: authonly,
            buyerpubkey: wallet.Path1899.publicKey,
            signature: sigBuf.toString('hex'),
            paymentdata: msgBuf.toString('hex')
        });

        return { payment, kycToken, coinsUsed };
    }

    const sendPayment = async (rawPayment) => {
        const rawResponse = await fetch("https://lsbx.nmrai.com/v1/pay", {
            method: "POST",
            headers: new Headers({
                'Content-Type': `application/fiat-payment`
            }),
            signal: AbortSignal.timeout(20000),
            body: rawPayment
        });

        return rawResponse;
    }

    const capturePayment = async () => {
        try {
            await sleep(8000);

            let response;
            for (let retries = 0; retries < 3; retries++) {
                console.log("capture payment attempt", retries);
                const rawPaymentRes = await sendPayment(authPayment.rawPayment);

                if (rawPaymentRes.status == 200) {
                    const paymentResArrayBuf = await rawPaymentRes.arrayBuffer();
                    response = Buffer.from(paymentResArrayBuf);
                    break;
                } else if (rawPaymentRes.status == 400) {
                    const msg = await rawPaymentRes.text();
                    console.log("msg", msg);
                    console.log("rawPaymentRes", rawPaymentRes);

                    if (retries < 2) {
                        // retry 3 times in total
                        await sleep(3000)
                        continue;
                    } else {
                        // too many retries
                        throw new Error(msg);
                    }
                } else {
                    throw new Error(msg);
                }
            }

            console.log("response", response);

            const ack = PaymentACK.fromRaw(response);
            console.log(ack.memo);
            const rawTransactions = ack.payment.transactions;
            const ticketTxs = rawTransactions.map(r => TX.fromRaw(r));
            console.log(ticketTxs.map(tx => tx.toJSON()));

            setTicketIssued(true);
            notify({ type: 'success', message: 'Successful Purchase' });

            // put txs in storage
            const capturedPayment = Payment.fromRaw(authPayment.rawPayment);
            const paymentTxs = capturedPayment.transactions.map(raw => TX.fromRaw(raw));
            await addIssueTxs(ticketTxs, authPayment.coinsUsed, paymentTxs);

            history.push('/backup');

        } catch (err) {
            console.error(err);
            setLoadingStatus("AN ERROR OCCURED");
            await sleep(2000);
            return repeatOnboarding();
        }
    }

    const setKycResult = async () => {
        try {
            await sleep(8000);
            for (let retries = 0; retries < 2; retries++) {
                console.log("set kyc result, attempt", retries)
                const rawPaymentRes = await sendPayment(authPayment.rawPayment);

                if (rawPaymentRes.status == 400) {
                    const msg = await rawPaymentRes.text();
                    console.log("msg", msg);

                    // status 400 and db confirmation: repeat onboarding
                    if (msg?.includes("Invalid") || msg?.includes("review") || msg?.includes("error"));
                    return repeatOnboarding();

                    if (msg?.includes("cancelled")) {
                        setLoadingStatus(false);
                        return;
                    }

                    if (retries < 1) {
                        await sleep(3000)
                        continue;
                    } else {
                        // too many retries
                        throw new Error(msg);
                    }
                }
            }
        } catch (err) {
            console.error(err);
            setLoadingStatus("AN ERROR OCCURED");
            await sleep(2000);
            return repeatOnboarding();
        }
    }

    // handle user agreement with terms of service
    const handleAgree = async (e) => {
        e.preventDefault();
        setHasAgreed(true);
        await sleep(500);
        setFirstRendering(false);
    }

    const handleKYCResult = async (result) => {
        console.log("KYC", result.status);
        const isFiat = paymentProcessor !== "etoken";
        console.log("isFiat", isFiat);
        switch (result.status) {

            // ----Incomplete workflow-----
            case "user_cancelled":
                if (kycCancelCount == 0 && !user.kyc_status?.includes("cancelled")) {
                    console.log("increase counter");
                    notify({ type: 'error', message: 'KYC was cancelled, try again' });

                    setKycCancelCount(1);
                    break;
                } else {
                    setLoadingStatus("KYC WAS CANCELLED AGAIN");
                    await sleep(2000);
                    history.push("/select");
                }
            case "error":
                setLoadingStatus("A KYC ERROR OCCURED");
                return setKycResult();

            // ----Complete workflow-----
            case "auto_approved":
                if (isFiat) {
                    setLoadingStatus("CAPTURE PAYMENT")
                    return capturePayment();
                } else {
                    setShowKyc(false);
                    break;
                }
            case "auto_declined":
                setLoadingStatus("INVALID KYC");
                if (isFiat)
                    return setKycResult();
                else
                    return repeatOnboarding();
            case "needs_review":
                setLoadingStatus("KYC NEEDS REVIEW")
                return setKycResult();
        }
    }

    const handleKYC = async (e) => {
        e.preventDefault();

        const workflowId = "workflow_a93TCBh";
        const transactionId = wallet.Path1899.publicKey;
        const config = new window.HyperKycConfig(kycAccessToken, workflowId, transactionId);

        setKycConfig(config);
    }

    const handleEtokenPayment = async (e) => {
        if (e)
            e.preventDefault();
        setLoadingStatus("BUILDING TRANSACTION");
        await sleep(1000);
        setPaymentMetadata(true);
    }

    const handleReturn = () => {
        const previousPath = "/select";
        history.push(previousPath);
    }

    const handleConfirmation = async () => {
        // verify quantity input
        const isNumberInput = /[0-9]/.test(ticketQuantity);
        if (!isNumberInput) {
            setTicketQtyError("Quantity must be a number");
            return;
        }

        // verify sufficient balance
        const isEtoken = paymentProcessor === "etoken";
        const sufficientBalance = Number(ticketQuantity) <= maxEtokenTicketQuantity;
        if (isEtoken && !sufficientBalance) {
            if (maxEtokenTicketQuantity === 1)
                setTicketQtyError(`You can only afford ${maxEtokenTicketQuantity} Ticket with eToken`);
            else
                setTicketQtyError(`You can only afford ${maxEtokenTicketQuantity} Tickets with eToken`);
            return;
        }
        setTicketQtyError(false);

        await getPaymentRequest();

        if (!isEtoken)
            setShowPaymentForm(true);

        // kyc the user if first payment is with etoken
        if (isEtoken && !isKYCed) {
            setLoadingStatus("LOADING KYC");
            setShowKyc(true);
            // return handleEtokenPayment();
        } else if (isEtoken)
            return handleEtokenPayment();
    }

    const handleSubmitEmail = async (e) => {
        console.log("handleSubmitEmail called");
        e.preventDefault();

        const emailInput = e.target.email.value;
        const isValidEmail = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/.test(emailInput);
        if (!isValidEmail) {
            setEmailError("Invalid Email");
        }

        const countryInput = e.target.country.value;
        const isValidCountry = checkoutAllowedCountryOptions.map(({ value }) => value).includes(countryInput);
        if (!isValidCountry) {
            setCountryError(`Clux is unavailable in ${countryInput}`);
        }

        if (!isValidEmail || !isValidCountry)
            return;

        const buyerKeyring = KeyRing.fromSecret(wallet.Path1899.fundingWif);

        console.log("email", emailInput);
        console.log("user.access", user.access);
        const msg = Buffer.from(emailInput, 'utf-8');
        const sig = buyerKeyring.sign(SHA256.digest(msg));

        console.log("msg", msg);
        console.log("sig", sig);
        const json = {
            email: emailInput,
            pubkey: wallet.Path1899.publicKey,
            signature: sig.toString('hex'),
        };
        console.log("json", json);
        const userRes = await fetch("https://lsbx.nmrai.com/v1/user", {
            method: "POST",
            mode: "cors",
            headers: new Headers({
                "Content-Type": "application/json"
            }),
            signal: AbortSignal.timeout(20000),
            body: JSON.stringify(json)
        });
        console.log("userRes", userRes);
        // forward based on response
        const userResJson = await userRes.json();
        console.log("userResJson", userResJson);
        if (userRes.status === 200)
            setHasEmail(true);
    }

    const handlePaymentMethod = (method) => {
        setPaymentProcessor(method);
    }

    // NMI payment form
    useEffect(() => {
        window.CollectJS.configure({
            variant: 'lightbox',
            styleSniffer: false,
            callback: (token) => {
                console.log("token", token);
                handleNmiResult(token);
            },
            fields: {
                ccnumber: {
                    placeholder: "1234 1234 1234 1234",
                    selector: "#ccnumber"
                },
                ccexp: {
                    placeholder: "MM / YY",
                    selector: "#ccexp"
                },
                cvv: {
                    placeholder: "CVV",
                    selector: "#cvv"
                }
            },
            customCss: {
                "border-radius": "12px",
                "height": "44px",
                "border-style": "none"
            }
        })
    }, []);

    const handleNmiResult = async (result) => {
        console.log("payment token", result.token);
        const paymentMetadata = result.token;
        setPaymentMetadata(paymentMetadata);
    }

    const handleSubmit = (e) => {
        console.log("handleSubmit()")
        e.preventDefault();

        if (window.CollectJS) {
            window.CollectJS.startPaymentRequest();
        } else
            console.log("CollectJS unavailable")
    }

    return (
        <CheckoutContext.Provider
            value={{
                isFirstRendering,
                hasAgreed,
                hasEmail,
                showPaymentForm,
                ticketQtyError,
                emailError,
                countryError,
                showKyc,
                ticketQuantity,
                paymentProcessor,
                maxEtokenTicketQuantity,
                ticketPrice,
                handleReturn,
                handleAgree,
                handleKYC,
                handleConfirmation,
                handleSubmitEmail,
                handlePaymentMethod,
                handleSubmit,
                setTicketQuantity,  // <--- should be it's own function???
                setShowPaymentForm, // <--- should be it's own function???
            }}
        >
            {children}
        </CheckoutContext.Provider>
    );
}

export const useCheckout = () => {
    const context = useContext(CheckoutContext);
    if (!context) {
        throw new Error("useCheckout must be used within a CheckoutProvider");
    }
    return context;
};
